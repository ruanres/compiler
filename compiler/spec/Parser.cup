import java.io.*;
import java.util.*;
import java_cup.runtime.*;
import core.*;
import util.Logger;
init with {: Semantic.parser = this;              :};
parser code {:
    public void syntax_error(Symbol s) {
        String lexeme = s.value.toString();
        int line = s.right;
        int column = s.left;
        String error = String.format("Syntax error at %s at line %d, column %d", lexeme, line, column);
	    System.err.println(error);
    }
:};
terminal IDENTIFIER, I_CONSTANT, F_CONSTANT, STRING_LITERAL, FUNC_NAME, SIZEOF,
	PTR_OP, INC_OP, DEC_OP, LEFT_OP, RIGHT_OP, LE_OP, GE_OP, EQ_OP, NE_OP, AND_OP,
	OR_OP, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, LEFT_ASSIGN,
	RIGHT_ASSIGN, AND_ASSIGN, XOR_ASSIGN, OR_ASSIGN, TYPEDEF_NAME, ENUMERATION_CONSTANT,
	TYPEDEF, EXTERN, STATIC, AUTO, REGISTER, INLINE, CONST, RESTRICT, VOLATILE, BOOL,
	CHAR, SHORT, INT, LONG, SIGNED, UNSIGNED, FLOAT, DOUBLE, VOID, COMPLEX, IMAGINARY,
	STRUCT, UNION, ENUM, ELLIPSIS , CASE, DEFAULT, IF, ELSE, SWITCH, WHILE, DO, FOR,
	GOTO, CONTINUE, BREAK, RETURN, ALIGNAS, ALIGNOF, ATOMIC, GENERIC, NORETURN,
	STATIC_ASSERT, THREAD_LOCAL;
/* ---- Separators ---- */
terminal LPAREN;
terminal RPAREN;
terminal LBRACE;
terminal RBRACE;
terminal LBRACK;
terminal RBRACK;
terminal SEMICOLON;
terminal COMMA;
terminal DOT;
/* ---- Atribution ---- */
terminal EQ;
/* ---- Arithmetic operators ---- */
terminal PLUS;
terminal MINUS;
terminal MULT;
terminal DIV;
terminal MOD;

/* ---- Operator ---- */
terminal COLON;
/* ---- Logic operators----  */
terminal LT;
terminal GT;
terminal AND;
terminal NOT;
terminal COMP;
terminal OR;
terminal XOR;
terminal QUESTION;

non terminal translation_unit, primary_expression, constant, enumeration_constant, string, generic_selection, generic_assoc_list, generic_association, postfix_expression, argument_expression_list, expression, assignment_expression;
non terminal unary_operator, type_name, cast_expression, multiplicative_expression, additive_expression;
non terminal shift_expression, equality_expression, and_expression, exclusive_or_expression;
non terminal logical_and_expression, logical_or_expression, conditional_expression, constant_expression;
non terminal declaration_specifiers, init_declarator_list, storage_class_specifier, type_specifier, type_qualifier;
non terminal init_declarator, declarator, struct_or_union_specifier, struct_or_union, struct_declaration_list, struct_declaration;
non terminal initializer, specifier_qualifier_list, struct_declarator_list, struct_declarator, enum_specifier;
non terminal enumerator_list, enumerator, atomic_type_specifier, function_specifier, alignment_specifier, pointer, direct_declarator, parameter_type_list, identifier_list;
non terminal type_qualifier_list, parameter_declaration, abstract_declarator, direct_abstract_declarator;
non terminal initializer_list, designation, designator_list, designator, static_assert_declaration, statement, labeled_statement, compound_statement, block_item_list, block_item, selection_statement;
non terminal jump_statement, expression_statement, external_declaration, function_definition;
non terminal assignment_operator, parameter_list, unary_expression, iteration_statement, declaration_list;
non terminal relational_expression, inclusive_or_expression, declaration;

start with translation_unit;

primary_expression ::= IDENTIFIER:id         {:Logger.print("Line 72 IDENTIFIER: " + id); RESULT = Semantic.getInstance().getIdentifier((String) id); :}
                       | constant:c         {:RESULT = c; Logger.print("Line 73 " + c);:}
                       | string:s						{:Logger.print("Line 74 - String"); RESULT = s;:}
	                     | LPAREN expression RPAREN  {:Logger.print("Line 75");:}
                       | generic_selection	{:Logger.print("Line 76");:}
                       ;

constant ::= I_CONSTANT:i		/* includes character_constant */ {:Logger.print("Line 79 I_CONSTANT: " + i); RESULT = new Expression(new Type("int"), i.toString());:}
	           | F_CONSTANT:f 	{:Logger.print("Line 80 F_CONSTANT: " + f); RESULT = new Expression(new Type("float"), f.toString());:}
	           | ENUMERATION_CONSTANT	/* after it has been defined as such */ {:Logger.print("Line 81");:}
	           ;

enumeration_constant		/* before it has been defined as such */
	::= IDENTIFIER			{:Logger.print("Line 85");:}
	;

string
	::= STRING_LITERAL:s				{: Logger.print("89 STRING_LITERAL: " + s); RESULT = s;:}
	| FUNC_NAME:f						{: Logger.print("90 FUNC_NAME: " + f); :}
	;

generic_selection
	::= GENERIC LPAREN assignment_expression COMMA generic_assoc_list RPAREN		{:Logger.print("Line 94");:}
	;

generic_assoc_list
	::= generic_association		{:Logger.print("Line 98");:}
	| generic_assoc_list COMMA generic_association		{:Logger.print("Line 99");:}
	;

generic_association
	::= type_name COLON assignment_expression			{:Logger.print("Line 103");:}
	| DEFAULT COLON assignment_expression				{:Logger.print("Line 104");:}
	;

postfix_expression
	::= primary_expression:pr			{:Logger.print("Line 108: " + pr); RESULT = pr; :}
	| postfix_expression LBRACK expression RBRACK		{:Logger.print("Line 109");:}
	| postfix_expression LPAREN RPAREN					{:Logger.print("Line 110");:}
	| postfix_expression LPAREN argument_expression_list RPAREN	{:Logger.print("Line 111");:}
	| postfix_expression DOT IDENTIFIER			{:Logger.print("Line 112");:}
	| postfix_expression PTR_OP IDENTIFIER		{:Logger.print("Line 113");:}
	| postfix_expression INC_OP					{:Logger.print("Line 114");:}
	| postfix_expression DEC_OP					{:Logger.print("Line 115");:}
	| LPAREN type_name LPAREN LBRACE initializer_list LBRACE	{:Logger.print("Line 116");:}
	| LPAREN type_name RPAREN LBRACE initializer_list COMMA RBRACE	{:Logger.print("Line 117");:}
	;

argument_expression_list
	::= assignment_expression		{:Logger.print("Line 121");:}
	| argument_expression_list COMMA assignment_expression	{:Logger.print("Line 122");:}
	;

unary_expression
	::= postfix_expression:post				{:Logger.print("Line 126 postfix: " + post); RESULT=post;:}
	| INC_OP unary_expression			{:Logger.print("Line 127");:}
	| DEC_OP unary_expression			{:Logger.print("Line 128");:}
	| unary_operator cast_expression	{:Logger.print("Line 129");:}
	| SIZEOF unary_expression			{:Logger.print("Line 130");:}
	| SIZEOF LPAREN type_name RPAREN	{:Logger.print("Line 131");:}
	| ALIGNOF LPAREN type_name RPAREN	{:Logger.print("Line 132");:}
	;

unary_operator
	::= AND		{:Logger.print("Line 136");:}
	| MULT		{:Logger.print("Line 137");:}
	| PLUS		{:Logger.print("Line 138");:}
	| MINUS		{:Logger.print("Line 139");:}
	| COMP		{:Logger.print("Line 140");:}
	| NOT		{:Logger.print("Line 141");:}
	;

cast_expression
	::= unary_expression:un						{:Logger.print("Line 145 unary_expression: " + un); RESULT = un;:}
	| LPAREN type_name RPAREN cast_expression	{:Logger.print("Line 146");:}
	;

multiplicative_expression
	::= cast_expression:ca									{:Logger.print("Line 150 cast_expression: " + ca); RESULT=ca;:}
	| multiplicative_expression MULT cast_expression	{:Logger.print("Line 151");:}
	| multiplicative_expression DIV cast_expression		{:Logger.print("Line 152");:}
	| multiplicative_expression MOD cast_expression		{:Logger.print("Line 153");:}
	;

additive_expression
	::= multiplicative_expression:multi_exp							{:Logger.print("Line 157 mult_exp: " + multi_exp); RESULT=multi_exp;:}
	| additive_expression PLUS multiplicative_expression	{:Logger.print("Line 158");:}
	| additive_expression MINUS multiplicative_expression	{:Logger.print("Line 159");:}
	;

shift_expression
	::= additive_expression:add_exp								{:Logger.print("Line 163 add_exp: " + add_exp); RESULT=add_exp;:}
	| shift_expression LEFT_OP additive_expression		{:Logger.print("Line 164");:}
	| shift_expression RIGHT_OP additive_expression		{:Logger.print("Line 165");:}
	;

relational_expression
	::= shift_expression:shift									{: Logger.print("Line 169 shift_expression: "  + shift); RESULT=shift; :}
	| relational_expression:e1 LT shift_expression:e2				{: Logger.print("Line 170 LESS THAN"); Semantic.getInstance().isRelationalExpression((Expression) e1, (Expression) e2);:}
	| relational_expression:e1 GT shift_expression:e2			{: Logger.print("Line 171 GREATER THAN"); Semantic.getInstance().isRelationalExpression((Expression) e1, (Expression) e2); :}
	| relational_expression:e1 LE_OP shift_expression:e2			{: Logger.print("Line 172 LESS EQUAL"); Semantic.getInstance().isRelationalExpression((Expression) e1, (Expression) e2); :}
	| relational_expression:e1 GE_OP shift_expression:e2			{: Logger.print("Line 173 GREATER EQUAL"); Semantic.getInstance().isRelationalExpression((Expression) e1, (Expression) e2); :}
	;

equality_expression
	::= relational_expression:rel								{: Logger.print("Line 177 relational_expression: " + rel); RESULT=rel;:}
	| equality_expression:e1 EQ_OP relational_expression:e2		{: Logger.print("Line 178 EQUAL"); Semantic.getInstance().isRelationalExpression((Expression) e1, (Expression) e2); :}
	| equality_expression:e1 NE_OP relational_expression:e2		{: Logger.print("Line 179 NOT EQUAL"); Semantic.getInstance().isRelationalExpression((Expression) e1, (Expression) e2); :}
	;

and_expression
	::= equality_expression:eq_exp						{:Logger.print("Line 183 equality_expression: " + eq_exp); RESULT=eq_exp;:}
	| and_expression AND equality_expression	{:Logger.print("Line 184");:}
	;

exclusive_or_expression
	::= and_expression:and_exp								{:Logger.print("Line 188 and_expression: " + and_exp); RESULT=and_exp;:}
	| exclusive_or_expression XOR and_expression	{:Logger.print("Line 189");:}
	;

inclusive_or_expression
	::= exclusive_or_expression:ex_or_exp								{:Logger.print("Line 193 exclusive_or_expression: " + ex_or_exp); RESULT=ex_or_exp;:}
	| inclusive_or_expression OR exclusive_or_expression	{:Logger.print("Line 194");:}
	;

logical_and_expression
	::= inclusive_or_expression:in_or_exp								{:Logger.print("Line 198 inclusive_or_expression: " + in_or_exp); RESULT=in_or_exp;:}
	| logical_and_expression AND_OP inclusive_or_expression	{:Logger.print("Line 199");:}
	;

logical_or_expression
	::= logical_and_expression:log_and_exp								{:Logger.print("Line 203 logical_and_expression: " + log_and_exp); RESULT=log_and_exp;:}
	| logical_or_expression OR_OP logical_and_expression	{:Logger.print("Line 204");:}
	;

conditional_expression
	::= logical_or_expression:log_or_exp													{:Logger.print("Line 208 logical_or_expression: " + log_or_exp); RESULT=log_or_exp;:}
	| logical_or_expression QUESTION expression COLON conditional_expression	{:Logger.print("Line 209");:}
	;

assignment_expression
	::= conditional_expression:cond_exp										{:Logger.print("Line 213 conditional_expression: " + cond_exp); RESULT=cond_exp;:}
	| unary_expression:un_exp assignment_operator:as_op assignment_expression:as_exp	{:Logger.print("Line 214 unary_expression: " + un_exp + " assignment_operator: " + as_op + " assignment_expression: " + as_exp); RESULT=as_exp;:}
	;

assignment_operator
	::= EQ			    {:Logger.print("Line 218 EQ"); RESULT= new Node("=","primary", "PLUS");:}
	| MUL_ASSIGN	  {:Logger.print("Line 219 MUL_ASSIGN"); RESULT= new Node("*=","primary", "MUL_ASSIGN");:}
	| DIV_ASSIGN	  {:Logger.print("Line 220 DIV_ASSIGN"); RESULT= new Node("/=","primary", "DIV_ASSIGN");:}
	| MOD_ASSIGN	  {:Logger.print("Line 221 MOD_ASSIGN"); RESULT= new Node("%=","primary", "MOD_ASSIGN");:}
	| ADD_ASSIGN	  {:Logger.print("Line 222 ADD_ASSIGN"); RESULT= new Node("+=","primary", "ADD_ASSIGN");:}
	| SUB_ASSIGN	  {:Logger.print("Line 223 SUB_ASSIGN"); RESULT= new Node("-=","primary", "SUB_ASSIGN");:}
	| LEFT_ASSIGN	  {:Logger.print("Line 224 LEFT_ASSIGN"); RESULT= new Node("<<=","primary", "LEFT_ASSIGN");:}
	| RIGHT_ASSIGN	{:Logger.print("Line 225 RIGHT_ASSIGN"); RESULT= new Node(">>=","primary", "RIGHT_ASSIGN");:}
	| AND_ASSIGN	  {:Logger.print("Line 226 AND_ASSIGN"); RESULT= new Node("&=","primary", "AND_ASSIGN");:}
	| XOR_ASSIGN	  {:Logger.print("Line 227 XOR_ASSIGN"); RESULT= new Node("^=","primary", "XOR_ASSIGN");:}
	| OR_ASSIGN		  {:Logger.print("Line 228 OR_ASSIGN"); RESULT= new Node("|=","primary", "OR_ASSIGN");:}
	;

expression
	::= assignment_expression:assign_exp					{:Logger.print("Line 232 assignment_expression: " + assign_exp); RESULT=assign_exp;:}
	| expression COMMA assignment_expression	{:Logger.print("Line 233");:}
	;

constant_expression
	::= conditional_expression	/* with constraints */ {:Logger.print("Line 237");:}
	;

declaration
	::= declaration_specifiers SEMICOLON		{:Logger.print("Line 241");:}
	| declaration_specifiers:decl_types init_declarator_list:decl_vars SEMICOLON		{:Logger.print("Line 242 declaration_specifiers: " + decl_types + " init_declarator_list: " + decl_vars);RESULT=decl_vars;((Variable) decl_vars).setType((Type) decl_types); Semantic.getInstance().addVariable((Variable) decl_vars);:}
	| static_assert_declaration		{:Logger.print("Line 243");:}
	;

declaration_specifiers
	::= storage_class_specifier declaration_specifiers	{:Logger.print("Line 247");:}
	| storage_class_specifier							{:Logger.print("Line 248");:}
	| type_specifier declaration_specifiers				{:Logger.print("Line 249");:}
	| type_specifier:ty									{:Logger.print("Line 250 type_specifier: " + ty);RESULT=ty;:}
	| type_qualifier declaration_specifiers				{:Logger.print("Line 251");:}
	| type_qualifier									{:Logger.print("Line 252");:}
	| function_specifier declaration_specifiers			{:Logger.print("Line 253");:}
	| function_specifier								{:Logger.print("Line 254");:}
	| alignment_specifier declaration_specifiers		{:Logger.print("Line 255");:}
	| alignment_specifier								{:Logger.print("Line 256");:}
	;

init_declarator_list
	::= init_declarator:init_decl								{:Logger.print("Line 260 init_declarator: " + init_decl); RESULT=init_decl;:}
	| init_declarator_list COMMA init_declarator	{:Logger.print("Line 261");:}
	;

init_declarator
	::= declarator:de EQ initializer:in					{:Logger.print("Line 265 declarator: " + de + " initializer: " + in); Variable temp = new Variable((String) de,new Type("null")); RESULT = temp;:}
	| declarator:de									{:Logger.print("Line 266 declarator: " + de);:}
	;

storage_class_specifier
	::= TYPEDEF	/* identifiers must be flagged as TYPEDEF_NAME */ {:Logger.print("Line 270");:}
	| EXTERN		{:Logger.print("Line 271");:}
	| STATIC		{:Logger.print("Line 272");:}
	| THREAD_LOCAL	{:Logger.print("Line 273");:}
	| AUTO			{:Logger.print("Line 274");:}
	| REGISTER		{:Logger.print("Line 275");:}
	;

type_specifier
	::= VOID     {:RESULT = new Type("void"); Logger.print("VOID at line 279");:}
	| CHAR       {:RESULT = new Type("char"); Logger.print("CHAR at line 280");:}
	| SHORT      {:RESULT = new Type("short"); Logger.print("SHORT at line 281");:}
	| INT        {:RESULT = new Type("int"); Logger.print("INT at line 282");:}
	| LONG       {:RESULT = new Type("long"); Logger.print("LONG at line 283");:}
	| FLOAT      {:RESULT = new Type("float"); Logger.print("FLOAT at line 284");:}
	| DOUBLE     {:RESULT = new Type("double"); Logger.print("DOUBLE at line 285");:}
	| SIGNED     {:RESULT = new Type("signed"); Logger.print("SIGNED at line 286");:}
	| UNSIGNED   {:RESULT = new Type("unsigned"); Logger.print("UNSIGNED at line 287");:}
	| BOOL       {:RESULT = new Type("bool"); Logger.print("BOOL at line 288");:}
	| COMPLEX    {:RESULT = new Type("complex"); Logger.print("COMPLEX at line 289");:}
	| IMAGINARY	  	/* non-mandated extension */ {:Logger.print("Line 290");:}
	| atomic_type_specifier		{:Logger.print("Line 291");:}
	| struct_or_union_specifier	{:Logger.print("Line 292");:}
	| enum_specifier			{:Logger.print("Line 293");:}
	| TYPEDEF_NAME		/* after it has been defined as such */ {:Logger.print("Line 294");:}
	;

struct_or_union_specifier
	::= struct_or_union LBRACE struct_declaration_list RBRACE				{:Logger.print("Line 298");:}
	| struct_or_union IDENTIFIER LBRACE struct_declaration_list RBRACE		{:Logger.print("Line 299");:}
	| struct_or_union IDENTIFIER											{:Logger.print("Line 300");:}
	;

struct_or_union
	::= STRUCT		{:Logger.print("Line 304");:}
	| UNION			{:Logger.print("Line 305");:}
	;

struct_declaration_list
	::= struct_declaration							{:Logger.print("Line 309");:}
	| struct_declaration_list struct_declaration	{:Logger.print("Line 310");:}
	;

struct_declaration
	::= specifier_qualifier_list SEMICOLON	{:Logger.print("Line 314");:}
	| specifier_qualifier_list struct_declarator_list SEMICOLON	{:Logger.print("Line 315");:}
	| static_assert_declaration	{:Logger.print("Line 316");:}
	;

specifier_qualifier_list
	::= type_specifier specifier_qualifier_list		{:Logger.print("Line 320");:}
	| type_specifier								{:Logger.print("Line 321");:}
	| type_qualifier specifier_qualifier_list		{:Logger.print("Line 322");:}
	| type_qualifier								{:Logger.print("Line 323");:}
	;

struct_declarator_list
	::= struct_declarator								{:Logger.print("Line 327");:}
	| struct_declarator_list COMMA struct_declarator	{:Logger.print("Line 328");:}
	;

struct_declarator
	::= COLON constant_expression			{:Logger.print("Line 332");:}
	| declarator COLON constant_expression	{:Logger.print("Line 333");:}
	| declarator							{:Logger.print("Line 334");:}
	;

enum_specifier
	::= ENUM LBRACE enumerator_list RBRACE					{:Logger.print("Line 338");:}
	| ENUM LBRACE enumerator_list COMMA RBRACE				{:Logger.print("Line 339");:}
	| ENUM IDENTIFIER LBRACE enumerator_list RBRACE			{:Logger.print("Line 340");:}
	| ENUM IDENTIFIER LBRACE enumerator_list COMMA RBRACE	{:Logger.print("Line 341");:}
	| ENUM IDENTIFIER
	;

enumerator_list
	::= enumerator							{:Logger.print("Line 346");:}
	| enumerator_list COMMA enumerator		{:Logger.print("Line 347");:}
	;

enumerator	/* identifiers must be flagged as ENUMERATION_CONSTANT */
	::= enumeration_constant EQ constant_expression	{:Logger.print("Line 351");:}
	| enumeration_constant							{:Logger.print("Line 352");:}
	;

atomic_type_specifier
	::= ATOMIC LPAREN type_name RPAREN	{:Logger.print("Line 356");:}
	;

type_qualifier
	::= CONST			{:Logger.print("Line 360");:}
	| RESTRICT			{:Logger.print("Line 361");:}
	| VOLATILE			{:Logger.print("Line 362");:}
	| ATOMIC			{:Logger.print("Line 363");:}
	;

function_specifier
	::= INLINE			{:Logger.print("Line 367");:}
	| NORETURN			{:Logger.print("Line 368");:}
	;

alignment_specifier
	::= ALIGNAS LPAREN type_name RPAREN				{:Logger.print("Line 372");:}
	| ALIGNAS LPAREN constant_expression RPAREN		{:Logger.print("Line 373");:}
	;

declarator
	::= pointer direct_declarator			{:Logger.print("Line 377");:}
	| direct_declarator:d						{:RESULT = d; Logger.print("Line 378 direct_declarator: " + d);:}
	;

direct_declarator
	::= IDENTIFIER:d                 {: RESULT = d; Logger.print("Line 383 identifier: " + d);:}
	| LPAREN declarator RPAREN				{:Logger.print("Line 383");:}
	| direct_declarator LBRACK RBRACK		{:Logger.print("Line 384");:}
	| direct_declarator LBRACK MULT RBRACK	{:Logger.print("Line 385");:}
	| direct_declarator LBRACK STATIC type_qualifier_list assignment_expression RBRACK	{:Logger.print("Line 386");:}
	| direct_declarator LBRACK STATIC assignment_expression RBRACK		{:Logger.print("Line 387");:}
	| direct_declarator LBRACK type_qualifier_list MULT RBRACK			{:Logger.print("Line 388");:}
	| direct_declarator LBRACK type_qualifier_list STATIC assignment_expression RBRACK	{:Logger.print("Line 389");:}
	| direct_declarator LBRACK type_qualifier_list assignment_expression RBRACK			{:Logger.print("Line 390");:}
	| direct_declarator LBRACK type_qualifier_list RBRACK		{:Logger.print("Line 391");:}
	| direct_declarator LBRACK assignment_expression RBRACK		{:Logger.print("Line 392");:}
	| direct_declarator LPAREN parameter_type_list RPAREN		{:Logger.print("Line 393");:}
	| direct_declarator:dir_decl LPAREN RPAREN							{:Logger.print("Line 394 dir_decl: " + dir_decl); RESULT=dir_decl;:}
	| direct_declarator LPAREN identifier_list RPAREN			{:Logger.print("Line 395");:}
	;

pointer
	::= MULT type_qualifier_list pointer	{:Logger.print("Line 399");:}
	| MULT type_qualifier_list				{:Logger.print("Line 400");:}
	| MULT pointer							{:Logger.print("Line 401");:}
	| MULT									{:Logger.print("Line 402");:}
	;

type_qualifier_list
	::= type_qualifier						{:Logger.print("Line 406");:}
	| type_qualifier_list type_qualifier	{:Logger.print("Line 407");:}
	;


parameter_type_list
	::= parameter_list COMMA ELLIPSIS		{:Logger.print("Line 412");:}
	| parameter_list						{:Logger.print("Line 413");:}
	;

parameter_list
	::= parameter_declaration						{:Logger.print("Line 417");:}
	| parameter_list COMMA parameter_declaration	{:Logger.print("Line 418");:}
	;

parameter_declaration
	::= declaration_specifiers declarator			{:Logger.print("Line 422");:}
	| declaration_specifiers abstract_declarator	{:Logger.print("Line 423");:}
	| declaration_specifiers						{:Logger.print("Line 424");:}
	;

identifier_list
	::= IDENTIFIER									{:Logger.print("Line 428");:}
	| identifier_list COMMA IDENTIFIER				{:Logger.print("Line 429");:}
	;

type_name
	::= specifier_qualifier_list abstract_declarator	{:Logger.print("Line 433");:}
	| specifier_qualifier_list							{:Logger.print("Line 434");:}
	;

abstract_declarator
	::= pointer direct_abstract_declarator	{:Logger.print("Line 438");:}
	| pointer								{:Logger.print("Line 439");:}
	| direct_abstract_declarator			{:Logger.print("Line 440");:}
	;

direct_abstract_declarator
	::= LPAREN abstract_declarator RPAREN	{:Logger.print("Line 444");:}
	| LBRACK RBRACK							{:Logger.print("Line 445");:}
	| LBRACK MULT RBRACK					{:Logger.print("Line 446");:}
	| LBRACK STATIC type_qualifier_list assignment_expression RBRACK	{:Logger.print("Line 447");:}
	| LBRACK STATIC assignment_expression RBRACK						{:Logger.print("Line 448");:}
	| LBRACK type_qualifier_list STATIC assignment_expression RBRACK	{:Logger.print("Line 449");:}
	| LBRACK type_qualifier_list assignment_expression RBRACK			{:Logger.print("Line 450");:}
	| LBRACK type_qualifier_list RBRACK									{:Logger.print("Line 451");:}
	| LBRACK assignment_expression RBRACK								{:Logger.print("Line 452");:}
	| direct_abstract_declarator LBRACK RBRACK							{:Logger.print("Line 453");:}
	| direct_abstract_declarator LBRACK MULT RBRACK						{:Logger.print("Line 454");:}
	| direct_abstract_declarator LBRACK STATIC type_qualifier_list assignment_expression RBRACK	{:Logger.print("Line 455");:}
	| direct_abstract_declarator LBRACK STATIC assignment_expression RBRACK						{:Logger.print("Line 456");:}
	| direct_abstract_declarator LBRACK type_qualifier_list assignment_expression RBRACK		{:Logger.print("Line 457");:}
	| direct_abstract_declarator LBRACK type_qualifier_list STATIC assignment_expression RBRACK	{:Logger.print("Line 458");:}
	| direct_abstract_declarator LBRACK type_qualifier_list RBRACK	{:Logger.print("Line 459");:}
	| direct_abstract_declarator LBRACK assignment_expression RBRACK	{:Logger.print("Line 460");:}
	| LPAREN RPAREN		{:Logger.print("Line 461");:}
	| LPAREN parameter_type_list RPAREN		{:Logger.print("Line 462");:}
	| direct_abstract_declarator LPAREN RPAREN	{:Logger.print("Line 463");:}
	| direct_abstract_declarator LPAREN parameter_type_list RPAREN	{:Logger.print("Line 464");:}
	;

initializer
	::= LBRACE initializer_list RBRACE		{:Logger.print("Line 468");:}
	| LBRACE initializer_list COMMA RBRACE	{:Logger.print("Line 469");:}
	| assignment_expression:assign_exp					{:Logger.print("Line 470 assignment_expression: " + assign_exp); RESULT=assign_exp;:}
	;

initializer_list
	::= designation initializer				{:Logger.print("Line 474");:}
	| initializer							{:Logger.print("Line 475");:}
	| initializer_list COMMA designation initializer	{:Logger.print("Line 476");:}
	| initializer_list COMMA initializer	{:Logger.print("Line 477");:}
	;

designation
	::= designator_list EQ	{:Logger.print("Line 481");:}
	;

designator_list
	::= designator	{:Logger.print("Line 485");:}
	| designator_list designator	{:Logger.print("Line 486");:}
	;

designator
	::= LBRACK constant_expression RBRACK	{:Logger.print("Line 490");:}
	| DOT IDENTIFIER						{:Logger.print("Line 491");:}
	;

static_assert_declaration
	::= STATIC_ASSERT LPAREN constant_expression COMMA STRING_LITERAL RPAREN SEMICOLON	{:Logger.print("Line 495");:}
	;

statement
	::= labeled_statement	{:Logger.print("Line 499");:}
	| compound_statement	{:Logger.print("Line 500");:}
	| expression_statement:exp_stat	{:Logger.print("Line 501 expression_statement: " + exp_stat); RESULT=exp_stat;:}
	| selection_statement	{:Logger.print("Line 502");:}
	| iteration_statement	{:Logger.print("Line 503");:}
	| jump_statement		{:Logger.print("Line 504");:}
	;

labeled_statement
	::= IDENTIFIER COLON statement	{:Logger.print("Line 508");:}
	| CASE constant_expression COLON statement	{:Logger.print("Line 509");:}
	| DEFAULT COLON statement		{:Logger.print("Line 510");:}
	;

compound_statement
  ::= LBRACE RBRACE					{:Logger.print("Line 514");:}
  | LBRACE  block_item_list RBRACE	{:Logger.print("Line 515");:}
  ;

block_item_list
	::= block_item:block					{:Logger.print("Line 519 block_item: " + block);RESULT=block;:}
	| block_item_list block_item:block	{:Logger.print("Line 520 block_item: " + block);RESULT=block;:}
	;

block_item
	::= declaration:decl					{:Logger.print("Line 524 declaration: " + decl);RESULT=decl;:}
	| statement:stat						{:Logger.print("Line 525 statement: " + stat); RESULT=stat;:}
	;

expression_statement
	::= SEMICOLON					{:Logger.print("Line 529");:}
	| expression:exp SEMICOLON			{:Logger.print("Line 530 expression: " + exp); RESULT=exp;:}
	;

selection_statement
	::= IF LPAREN expression RPAREN statement ELSE statement	{:Logger.print("Line 534");:}
	| IF LPAREN expression RPAREN statement		{:Logger.print("Line 535");:}
	| SWITCH LPAREN expression RPAREN statement	{:Logger.print("Line 536");:}
	;

iteration_statement
	::= WHILE LPAREN expression RPAREN statement	{:Logger.print("Line 540");:}
	| DO statement WHILE LPAREN expression RPAREN SEMICOLON	{:Logger.print("Line 541");:}
	| FOR LPAREN expression_statement expression_statement RPAREN statement	{:Logger.print("Line 542");:}
	| FOR LPAREN expression_statement expression_statement expression RPAREN statement	{:Logger.print("Line 543");:}
	| FOR LPAREN declaration expression_statement RPAREN statement	{:Logger.print("Line 544");:}
	| FOR LPAREN declaration expression_statement expression RPAREN statement	{:Logger.print("Line 545");:}
	;

jump_statement
	::= GOTO IDENTIFIER SEMICOLON	{:Logger.print("Line 549");:}
	| CONTINUE SEMICOLON			{:Logger.print("Line 550");:}
	| BREAK SEMICOLON				{:Logger.print("Line 551");:}
	| RETURN SEMICOLON				{:Logger.print("Line 552");:}
	| RETURN expression SEMICOLON	{:Logger.print("Line 553");:}
	;

translation_unit
	::= external_declaration				{:Logger.print("Line 557");:}
	| translation_unit external_declaration	{:Logger.print("Line 558");:}
	;

external_declaration
	::= function_definition		{:Logger.print("Line 562");:}
	| declaration				{:Logger.print("Line 563");:}
	;

function_definition
	::= declaration_specifiers declarator declaration_list compound_statement	{:Logger.print("Line 567");:}
	| declaration_specifiers declarator compound_statement						{:Logger.print("Line 568");:}
	;

declaration_list
	::= declaration					{:Logger.print("Line 572");:}
	| declaration_list declaration	{:Logger.print("Line 573");:}
	;
